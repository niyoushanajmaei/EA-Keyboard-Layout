
- The link for QAPLIB doesn't work
- What is a model?
- How do these encodings make sense?

- We thought of the following improvements: 
    - Comparing different crossover functions: Create our own special crossover
    - Have some heuristic for the initial assignment of keys: Help converge sooner
        - The keys which frequently appear in a bigram should be on different sides of the keyboard
        - The letters with less frequency of appearance should be on the edge of the keyboard. The ones that are more frequently used, should be in the middle
    - Determine the degree of the Markov chain we should be using?
    - Change the fitness function: 
        - Does this fitness function assume that the keyboard is only used with one finger?
        - Add regions in the keyboard and use the fitness function for each region independently?

- TA's Suggestions: 
    - Everyone can try different initializations
    - Create our own Special crossover
    - Include other search components like evolutionary local search
    - have a permutation at the beginning
    - dynamically change parameters of differential evolution (like learning rate scheduling), look at adaptive differential evolution literature
    - Select a good baseline: works, progresses over time, doesn't prematurely converge, shouldn't necessarily reach the optimum, not too easy to beat
    - Evaluate: 
        - within a certain number of function calls, what is the best solution? (fixed budget)
        - Run for a certain amount of time, and see how it converges: convergence plots (fixed budget)
        - iohprofiler.github.io
        - How long (in terms of function calls or time) until we get a solution within 5 or 10 percent of the optimum (fixed target)
        - Pick either fixed budget or fixed target
        - looking only at time : not reproducible
    - Evaluation: 
        - Fixed budget
        - Fixed target
        - What is the .... when every single run finds the optimum. 